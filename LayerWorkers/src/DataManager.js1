import Utils from './Utils';
import Requests from './Requests';
import Store from './Store';
import TilesLoader from './TilesLoader';
import RasterItems from './RasterItems';
import Renderer2d from './Renderer2d';
// import Observer from './Observer';

// let hosts = {},
let	hover = {},
    tiles,
    geometry,
    properties,
	tileAttributeIndexes,
	tileAttributeTypes,
	styles,
	versionPromise,
	drawScreenCom,
	// dateInterval = {},
    // bbox = null,
mapSize,
pOrigin,
matrix,
	_ctxLabels;
	// dataManagersLinks = {},
    // hostBusy = {},
    // needReq = {}
const _parseTileRange = (data) => {
	const tileRange = data.tileRange;
	const zoom = data.zoom;
	const queue = [];
	const tHash = {};
	const pz = Math.pow(2, zoom);
	for (let j = tileRange.min.y; j <= tileRange.max.y; j++) {
		for (let i = tileRange.min.x; i <= tileRange.max.x; i++) {
			const real = {
				z: zoom,
				x: i % pz + (i < 0 ? pz : 0),
				y: j % pz + (j < 0 ? pz : 0)
			};
			const rKey = real.x + ':' + real.y + ':' + zoom;
			tHash[rKey] = real;
			queue.push({x: i, y: j, z: zoom});
			
		}
	}
	return {tHash, queue};
}
const drawLayer = async (data, resolve) => {
	// const pz = _parseTileRange(data);
	const tRange = _parseTileRange(data);
	let rasters;
	if (properties.IsRasterCatalog) {
		rasters = await RasterItems.getNeedRasterItems({tiles, tileAttributeIndexes, properties, tRange, mapSize, matrix});
	}

	const queue = [];
	const tHash = {};
	// const w = 256, h = 256;
let canvas;

	if (mapSize && (!canvas || mapSize.x !== canvas.width || mapSize.y !== canvas.height)) {
		const w = mapSize.x, h = mapSize.y;
		canvas = new OffscreenCanvas(w, h);
		canvas.width = w; canvas.height = h;
	}

	tiles.forEach(it => {
		it.paths.forEach(it1 => {
			Renderer2d.updatePolyMerc({paths: it1, _ctx: canvas.getContext('2d'), matrix: data.matrix});
		});
	});
console.log('drawLayer1',mapSize, data, rasters, tiles, versionPromise);
		// for (let j = tileRange.min.y; j <= tileRange.max.y; j++) {
			// for (let i = tileRange.min.x; i <= tileRange.max.x; i++) {
				// const real = {
					// z: zoom,
					// x: i % pz + (i < 0 ? pz : 0),
					// y: j % pz + (j < 0 ? pz : 0)
				// };
				// const rKey = real.x + ':' + real.y + ':' + zoom;
				// tHash[rKey] = real;
				// queue.push({x: i, y: j, z: zoom});
				
			// }
		// }

// console.log('drawLayer', data, tHash, queue, tiles, versionPromise);
	delete data.resolver;
	drawScreenCom = undefined;
					let bitmap = canvas.transferToImageBitmap();

	resolve({...data, bitmap});
};
/*
const initLayer = (data) => {
	geometry = data.origin.geometry;
	properties = data.origin.properties;
	return Utils.parseStyles(properties);
	// styles = await Utils.parseStyles(properties);
	// .then(st => {
// console.log('stylesPromise', st, properties);
	// });
// console.log('initLayer', styles);
};
*/
const version = async (data) => {
	if (!properties) {
		geometry = data.origin.geometry;
		properties = data.origin.properties;
		let tmp = Utils.getTileAttributes(properties);
		tileAttributeIndexes = tmp.tileAttributeIndexes;
		tileAttributeTypes = tmp.tileAttributeTypes;

		styles = await Utils.parseStyles(properties);
	}
	tiles = await TilesLoader.load(data);

	mapSize = data.mapSize;
	pOrigin = data.pOrigin;
	let pBounds = = data.pBounds;
	// const mInPixel = Math.pow(2, data.zoom + 8) / Utils.WORLDWIDTHFULL;
	// matrix = new DOMMatrix([mInPixel, 0, 0, mInPixel,
		// (Utils.WORLDWIDTHFULL/2 - data.topLeftMerc.x) * mInPixel - pBounds.min.x + pOrigin.x,
		// (Utils.WORLDWIDTHFULL/2 - data.topLeftMerc.y) * mInPixel - pBounds.min.y + pOrigin.y
	// ]);
	
	let rasters;
	if (drawScreenCom) {
		// drawScreenCom.matrix = matrix;
		// const tRange = _parseTileRange(drawScreenCom);
		// if (properties.IsRasterCatalog) rasters = await RasterItems.getNeedRasterItems({tiles, tileAttributeIndexes, tRange});
		drawLayer(drawScreenCom, drawScreenCom.resolver);
	}

// console.log('version', mapSize, styles, tiles, rasters);
	return new Promise(resolve => {
		const cmdNum = data.cmdNum;
		data.tilesPromise = tiles;
			resolve({cmdNum, tilesCount: tiles.length});
/*
			// console.log('___ tiles _____:', drawScreenCom, tiles);
		versionPromise = TilesLoader.load(data).then(res => {
			tiles = res.tiles;			// загрузили все нужные тайлы
			if (drawScreenCom) drawLayer(drawScreenCom, drawScreenCom.resolver);
			versionPromise = null;
			resolve({cmdNum, tilesCount: tiles.length});
		});
		*/
	});
};
const drawScreen = (data) => {
console.log('drawScreen', data, tiles, versionPromise);
/*
	// const mInPixel = Math.pow(2, data.zoom + 8) / Utils.WORLDWIDTHFULL;
	// data.matrix = new DOMMatrix([mInPixel, 0, 0, mInPixel,
		// (Utils.WORLDWIDTHFULL/2 - data.topLeftMerc.x) * mInPixel - pOrigin.x,
		// (Utils.WORLDWIDTHFULL/2 - data.topLeftMerc.y) * mInPixel - pOrigin.y
	// ]);

	return new Promise(resolve => {
		const cmdNum = data.cmdNum;
		if (versionPromise || !tiles) {
			data.resolver = resolve;
			drawScreenCom = data;
		} else {
			drawLayer(data, resolve);
		// TilesLoader.load(data).then(arr => {
			// tiles = arr;			// загрузили все нужные тайлы
			// console.log('___ tiles _____:', tiles);
		// });
		}
	});
*/
};

export default {
	drawScreen,				// нужна отрисовка
	version,				// получили список тайлов для загрузки
	// setDateInterval,
	// sortLayersData,
	// setHover,
	// getTile,
	// getTiles,
	// drawItem,
	// drawLabels
};